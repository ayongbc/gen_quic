%%%-------------------------------------------------------------------
%%% @author alex <alex@alex-Lenovo>
%%% @copyright (C) 2018, alex
%%% @doc
%%%
%%% @end
%%% Created : 20 May 2018 by alex <alex@alex-Lenovo>
%%%-------------------------------------------------------------------
-module(quic_conn).

-behaviour(gen_statem).

%% API
-export([connect/4, listen/2, accept/2]).
-export([send/2, recv/3]).
-export([close/1]).

-export([start_link/1]).

%% gen_statem callbacks
-export([callback_mode/0, init/1, terminate/3, code_change/4]).
-export([handle_event/4]).

-include("quic_headers.hrl").

-record(data, {}).

%%%===================================================================
%%% API
%%%===================================================================

connect(Address, Port, Opts, Timeout) ->
  %% Start gen_statem process, state opening.
  ?DBG("Starting statem~n", []),
  {ok, Pid} = start_link(Opts),

  ?DBG("Connecting to ~p on port ~p~n", [Address, Port]),
  %% Try to connect the socket to the server.
  case call(Pid, {connect, Address, Port, Timeout}) of
    {ok, Socket} ->
      %% Associate the Socket with the gen_statem Pid.
      quic_db:add_conn(Socket, Pid),
      {ok, Socket};
    Error ->
      Error
  end.


listen(Port, Opts) ->
  ?DBG("Starting statem~n", []),
  %% Start the gen_statem process, state opening.
  {ok, Pid} = start_link(Opts),

  %% Transition to listen state.
  case call(Pid, {listen, Port}) of
    {ok, Socket} ->
      ?DBG("Listening on port ~p~n", [Port]),
      %% Associate the Socket with the gen_statem Pid.
      quic_db:add_conn(Socket, Pid),
      {ok, Socket};
    Error ->
      Error
  end.


accept(Socket, Timeout) ->
  ?DBG("Waiting to accept.~n", []),
  %% Lookup statem pid for socket
  {ok, {Socket, Pid}} = quic_db:lookup(Socket),

  case call(Pid, {accept, Timeout}) of
    {ok, {new, Client_Socket, IP, Port}} ->
      ?DBG("New connection from ~p:~p~n", [IP, Port]),
      %% perform version negotiation after receiving a request.
      case call(Pid, {vsn_neg}) of
        ok ->
          ?DBG("Version negotiation successful~n", []),
          {ok, Client_Socket};
        Error ->
          Error
      end;
    {ok, {existing, Client_Socket}} ->
      ?DBG("Reconnection from ~p:~p~n", [IP, Port]),
      %% TODO: change stuff related to reconnection
      %% For now just return socket.
      {ok, Client_Socket};
    Accept_Error ->
      Accept_Error
  end.


send(Socket, Data) ->
  ?DBG("Sending on Socket ~p, ~p~n", [Socket, Data]),
  %% lookup socket.
  {ok, {Socket, Pid}} = quic_db:lookup(Socket),
  %% format data
  case call(Pid, {format, Data}) of
    ok ->
      ?DBG("Data formatted~n", []),
      case call(Pid, send) of
        ok ->
          ?DBG("Data sending~n", []),
          case call(Pid, recovery) of
            ok ->
              ?DBG("Acks received~n", []),
              cast(Pid, standby);
            Conn_Error ->
              Conn_Error
          end;
        Send_Error ->
          Send_Error
      end;
    Format_Error ->
      Format_Error
  end.

recv(Socket, _Length, Timeout) ->



  %%--------------------------------------------------------------------
  %% @doc
  %% Creates a gen_statem process which calls Module:init/1 to
  %% initialize. To ensure a synchronized start-up procedure, this
  %% function does not return until Module:init/1 has returned.
  %%
  %% @end
  %%--------------------------------------------------------------------
  -spec start_link(Socket :: inet:socket()) ->
                                   {ok, Pid :: pid()} |
                                   ignore |
                                   {error, Error :: term()}.

start_link(Opts) ->
  gen_statem:start_link(?MODULE, [Opts], []).

%%%===================================================================
%%% gen_statem callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Define the callback_mode() for this callback module.
%% @end
%%--------------------------------------------------------------------
-spec callback_mode() -> gen_statem:callback_mode_result().
callback_mode() -> handle_event_function.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Whenever a gen_statem is started using gen_statem:start/[3,4] or
%% gen_statem:start_link/[3,4], this function is called by the new
%% process to initialize.
%% @end
%%--------------------------------------------------------------------
-spec init(Args :: term()) ->
              gen_statem:init_result(term()).
init([Opts]) ->
  process_flag(trap_exit, true),
  {ok, open, #quic_conn{opts=Opts}}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% This function is called for every event a gen_statem receives.
%% @end
%%--------------------------------------------------------------------
-spec handle_event('enter',
		   OldState :: term(),
		   State :: term(),
		   Data :: term()) ->
                      gen_statem:state_enter_result(term());
		  (gen_statem:event_type(),
		   Msg :: term(),
		   State :: term(),
		   Data :: term()) ->
                      gen_statem:event_handler_result(term()).

%% Connect state change from open to version_neg.
handle_event({call, From}, 
	     {connect, Address, Port, Timeout}, 
	     open, 
	     #quic_conn{opts=Opts}=Data) ->
  {ok, LSocket} = quic_prim:open(Opts),
  case do_connect(LSocket, Address, Port, Timeout) of
    {ok, Conn} ->
      %% successful connection. Enter vsn_neg state and reply with socket.
      {next_state, vsn_neg, Conn, [{reply, From, {ok, LSocket}}]};
    Error ->
      %% unsuccessful connection. Close the statem.
      {stop, Error, Data}
  end;

handle_event({call, _From}, 
	     {listen, Port}, 
	     open, 
	     Data) -> 
  ok;


handle_event({call,From}, _Msg, State, Data) ->
  {next_state, State, Data, [{reply,From,ok}]}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% This function is called by a gen_statem when it is about to
%% terminate. It should be the opposite of Module:init/1 and do any
%% necessary cleaning up. When it returns, the gen_statem terminates with
%% Reason. The return value is ignored.
%% @end
%%--------------------------------------------------------------------
-spec terminate(Reason :: term(), State :: term(), Data :: term()) ->
                   any().
terminate(_Reason, _State, _Data) ->
  void.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Convert process state when code is changed
%% @end
%%--------------------------------------------------------------------
-spec code_change(
	OldVsn :: term() | {down,term()},
	State :: term(), Data :: term(), Extra :: term()) ->
                     {ok, NewState :: term(), NewData :: term()} |
                     (Reason :: term()).
code_change(_OldVsn, State, Data, _Extra) ->
  {ok, State, Data}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

%% Simple functions to just cut down on wordage.
call(Pid, Msg) ->
  gen_statem:call(Pid, Msg).

cast(Pid, Msg) ->
  gen_statem:cast(Pid, Msg).
