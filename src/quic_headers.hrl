%% This comprises of the define statements needed to build default quic 
%% packet and frame headers.


%% I will definitely have to make sure that these are correctly used throughout and
%% probably prune them down to have fewer repeated fields.

-type stream_id() :: non_neg_integer().
-type offset() :: non_neg_integer().
-type conn_id() :: binary().

%% Maybe change error_code to an atom to be more descriptive.
-type error_code() :: non_neg_integer() | binary().

-export_type([stream_id/0, offset/0, conn_id/0, error_code/0]).

-type quic_conn() ::
        #{
          socket        => gen_quic:socket(),
          address       => inet:ip_address(),
          port          => inet:port_number(),
          owner         => pid(),
          dest_conn_ID  => conn_id(),
          src_conn_ID   => conn_id()
         }.

-type tls_version() :: non_neg_integer().
-export_type([tls_version/0]).

%% Will probably need a few more fields when expanded past current hard-coding.
-type quic_crypto() ::
        #{
          state  => atom(),
          %% Offsets are initialized at 0 and incremented after use.
          init_offsets        => {non_neg_integer(), non_neg_integer()},
          handshake_offsets   => {non_neg_integer(), non_neg_integer()},
          protected_offsets   => {non_neg_integer(), non_neg_integer()},
          init_secret         => binary(),
          pkt_num_init_secret => binary(),
          client_init_secret  => binary(),
          server_init_secret  => binary(),
          client_init_key     => binary(),
          client_init_iv      => binary(),
          server_init_key     => binary(),
          server_init_iv      => binary(),
          handshake_secret    => binary(),
          client_early_key    => binary(),
          client_early_iv     => binary(),
          pkt_num_handshake_secret => binary(),
          client_handshake_secret  => binary(),
          server_handshake_secret  => binary(),
          client_handshake_key     => binary(),
          client_handshake_iv      => binary(),
          server_handshake_key     => binary(),
          server_handshake_iv      => binary(),
          protected_secret         => binary(),
          pkt_num_protected_secret => binary(),
          client_protected_secret  => binary(),
          server_protected_secret  => binary(),
          client_protected_key     => binary(),
          client_protected_iv      => binary(),
          server_protected_key     => binary(),
          server_protected_iv      => binary(),
          transcript    => binary(),
          tls_version   => undefined | tls_version(),
          cert_chain    => [binary()], %% This starts with the root cert and leads to the peer cert.
          cert          => undefined | binary(),
          cert_priv_key => undefined | binary(),
          pub_key       => undefined | binary(),
          priv_key      => undefined | binary(), %% If not generated by/for a certificate (ephemeral)
          other_pub_key => undefined | term(),
          cipher        => undefined | {atom(), atom()},
          signature_alg => undefined | {atom(), atom(), atom()},
          group         => undefined | any() %%group()
         }.

-type group() :: {atom(), atom()}.

-type version() :: binary().
-export_type([version/0]).

%% All the frame types and fields.
-type quic_frame() ::
        #{
          type => padding,
          length => non_neg_integer(),
          binary => binary()
         }
      |
        #{
          type => ping,
          binary => binary()
         }
      |
        #{
          type => max_data,
          max_data => offset(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => max_stream_id,
          max_stream_id => stream_id(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => data_blocked,
          offset => offset(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => stream_id_blocked,
          stream_id => stream_id(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => path_challenge | path_response,
          challenge => binary(),
          binary => binary()
         }
      |
        #{
          type => stop_sending,
          stream_id => stream_id(),
          binary => binary()
         }
      |
        #{
          type => stream_data_blocked,
          stream_id => stream_id(),
          offset => offset(),
          stream_owner => 0 | 1,
          stream_type => 0 | 1,
          binary => binary(),
          retransmit => true
         }
      | 
        #{
          type => max_stream_data,
          stream_id => stream_id(),
          max_stream_data => offset(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => app_close | conn_close,
          error_code => error_code(),
          error_message => binary(),
          binary => binary()
         }
      | 
        #{
          type => rst_stream,
          stream_id => stream_id(),
          error_code => error_code(),
          binary => binary(),
          retransmit => true
         }
      | 
        #{
          type => new_conn_id,
          conn_id => conn_id(),
          token => binary(),
          sequence => integer(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => stream_open | stream_close | stream_data,
          stream_id => stream_id(),
          offset => offset(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => ack_frame,
          ack_delay => non_neg_integer(),
          largest => non_neg_integer(),
          acks => [non_neg_integer()],
          ecn_count => {non_neg_integer(), non_neg_integer(), non_neg_integer()},
          binary => binary()
         }
      | 
        #{type => crypto,
          crypto_type => encrypted_exts |
          server_hello |
          client_hello |
          certificate |
          cert_verify |
          finished,
          offset => non_neg_integer(),
          retransmit => true,
          binary => binary()}.

-export_type([quic_frame/0]).

%% These records will be used for default options given by connect
%% or listen. Only the Server can set preferred_address and reset_token
%% The params are communicated in the handshake messages by both parties.

%% Currently only one version.
-type quic_version() ::
        #{
          initial_version    => version(),
          negotiated_version => version(),
          supported_versions => [version()]
         }.


-type quic_pref_addr() ::
        #{
          address     => inet:ip_address(),
          port        => inet:port_number(),
          conn_id     => conn_id(),
          reset_token => binary()
         }.

-type quic_params() ::
        #{
          init_max_stream_data  => offset(),
          init_max_data         => offset(),
          idle_timeout          => non_neg_integer(),
          init_max_bi_streams   => non_neg_integer(),
          init_max_uni_streams  => non_neg_integer(),
          max_packet_size       => non_neg_integer(),
          ack_delay_exp         => non_neg_integer(),
          migration             => boolean(),
          reset_token           => binary(),
          preferred_address     => quic_pref_addr()
         }.

-type quic_data() ::
        #{
          type             => client | server,
          vx_module        => atom(),
          version          => quic_version(),
          conn             => quic_conn(),
          pkt_nums         => map(),
          timer_info       => map(),
          cc_info          => map(),
          send_queue       => quic_staging:staging(),
          priority_num     => non_neg_integer(),
          params           => quic_params(),
          current_data     => non_neg_integer(),
          crypto           => quic_crypto(),
          retry_token      => binary()
         }.

-type tls_record() ::
        #{
          type => atom(),
          quic_version => version(),
          other_quic_versions => [version()],
          offset => non_neg_integer(),
          length => non_neg_integer(),
          legacy_version => tls_version(),
          tls_supported_versions => [tls_version()],
          cipher_suites => [{atom(), atom()}],
          groups => [any()],
          supported_groups => [group()],
          peer_cert => binary(),
          root_cert => binary(),
          cert_chain => [binary()],
          key_share => [{group(), binary()}],
          signature => binary(),
          signature_algs => [{atom(), atom(), atom()}],
          cert_verify => binary(),
          server_cert_type => atom(),
          quic_params => quic_params(),
          temp_bin => binary() 
          %% This holds the binary of the tls record to add to the transcript
          %% after it is validated.
         }.

