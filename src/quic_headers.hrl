%% This comprises of the define statements needed to build default quic 
%% packet and frame headers.


%% I will definitely have to make sure that these are correctly used throughout and
%% probably prune them down to have fewer repeated fields.

-type stream_id() :: non_neg_integer().
-type offset() :: non_neg_integer().
-type conn_id() :: binary().

%% Maybe change error_code to an atom to be more descriptive.
-type error_code() :: non_neg_integer() | binary().

-export_type([stream_id/0, offset/0, conn_id/0, error_code/0]).

-record(quic_conn,
        {
         socket        :: undefined | gen_quic:socket(),
         address       :: undefined | inet:ip_address(),
         port          :: undefined | inet:port_number(),
         owner         :: undefined | pid(),
         dest_conn_ID  :: undefined | conn_id(),
         src_conn_ID   :: undefined | conn_id()
        }).

-type tls_version() :: non_neg_integer().
-export_type([tls_version/0]).

%% Will probably need a few more fields when expanded past current hard-coding.
-record(quic_crypto, 
        {
         state  :: atom(),
         %% Offsets are initialized at 0 and incremented after use.
         init_offsets      = {0, 0} :: {non_neg_integer(), non_neg_integer()},
         handshake_offsets = {0, 0} :: {non_neg_integer(), non_neg_integer()},
         protected_offsets = {0, 0} :: {non_neg_integer(), non_neg_integer()},
         init_secret         :: undefined | binary(),
         pkt_num_init_secret :: undefined | binary(),
         client_init_secret  :: undefined | binary(),
         server_init_secret  :: undefined | binary(),
         client_init_key     :: undefined | binary(),
         client_init_iv      :: undefined | binary(),
         server_init_key     :: undefined | binary(),
         server_init_iv      :: undefined | binary(),
         handshake_secret    :: undefined | binary(),
         client_early_key    :: undefined | binary(),
         client_early_iv     :: undefined | binary(),
         pkt_num_handshake_secret :: undefined | binary(),
         client_handshake_secret  :: undefined | binary(),
         server_handshake_secret  :: undefined | binary(),
         client_handshake_key     :: undefined | binary(),
         client_handshake_iv      :: undefined | binary(),
         server_handshake_key     :: undefined | binary(),
         server_handshake_iv      :: undefined | binary(),
         protected_secret         :: undefined | binary(),
         pkt_num_protected_secret :: undefined | binary(),
         client_protected_secret  :: undefined | binary(),
         server_protected_secret  :: undefined | binary(),
         client_protected_key     :: undefined | binary(),
         client_protected_iv      :: undefined | binary(),
         server_protected_key     :: undefined | binary(),
         server_protected_iv      :: undefined | binary(),
         transcript = <<>>        :: binary(),
         tls_version = 16#0304    :: tls_version(),
         cert_chain    :: undefined | [binary()], %% This starts with the root cert and leads to the peer cert.
         cert          :: undefined | binary(),
         cert_priv_key :: undefined | binary(),
         pub_key       :: undefined | binary(),
         priv_key      :: undefined | binary(), %% If not generated by/for a certificate (ephemeral)
         other_pub_key :: term(),
         cipher        :: undefined | {atom(), atom()},
         signature_alg :: undefined | {atom(), atom(), atom()},
         group         :: undefined | any() %%group()
        }).

-type group() :: {atom(), atom()}.

-type version() :: binary().
-export_type([version/0]).

%% All the frame types and fields.
-type quic_frame() ::
        #{
          type => padding,
          length => non_neg_integer(),
          binary => binary()
         }
      |
        #{
          type => ping,
          binary => binary()
         }
      |
        #{
          type => max_data,
          max_data => offset(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => max_stream_id,
          max_stream_id => stream_id(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => data_blocked,
          offset => offset(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => stream_id_blocked,
          stream_id => stream_id(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => path_challenge | path_response,
          challenge => binary(),
          binary => binary()
         }
      |
        #{
          type => stop_sending,
          stream_id => stream_id(),
          binary => binary()
         }
      |
        #{
          type => stream_data_blocked,
          stream_id => stream_id(),
          offset => offset(),
          stream_owner => 0 | 1,
          stream_type => 0 | 1,
          binary => binary(),
          retransmit => true
         }
      | 
        #{
          type => max_stream_data,
          stream_id => stream_id(),
          max_stream_data => offset(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => app_close | conn_close,
          error_code => error_code(),
          error_message => binary(),
          binary => binary()
         }
      | 
        #{
          type => rst_stream,
          stream_id => stream_id(),
          error_code => error_code(),
          binary => binary(),
          retransmit => true
         }
      | 
        #{
          type => new_conn_id,
          conn_id => conn_id(),
          token => binary(),
          sequence => integer(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => stream_open | stream_close | stream_data,
          stream_id => stream_id(),
          offset => offset(),
          binary => binary(),
          retransmit => true
         }
      |
        #{
          type => ack_frame,
          ack_delay => non_neg_integer(),
          largest => non_neg_integer(),
          acks => [non_neg_integer()],
          ecn_count => {non_neg_integer(), non_neg_integer(), non_neg_integer()},
          binary => binary()
         }
      | 
        #{type => crypto,
          crypto_type => encrypted_exts |
          server_hello |
          client_hello |
          certificate |
          cert_verify |
          finished,
          offset => non_neg_integer(),
          retransmit => true,
          binary => binary()}.

-export_type([quic_frame/0]).

%% These records will be used for default options given by connect
%% or listen. Only the Server can set preferred_address and reset_token
%% The params are communicated in the handshake messages by both parties.

%% Currently only one version.
-record(quic_version,
        {
         initial_version    :: undefined | version(),
         negotiated_version :: undefined | version(),
         supported_versions :: undefined | [version()]
        }).


-record(quic_pref_addr, 
        {
         address     :: undefined | inet:ip_address(),
         port        :: undefined | inet:port_number(),
         conn_id     :: undefined | conn_id(),
         reset_token :: undefined | binary()
        }).

-record(quic_params, 
        {
         init_max_stream_data  :: undefined | offset(),
         init_max_data         :: undefined | offset(),
         idle_timeout          :: undefined | non_neg_integer(),
         init_max_bi_streams   :: undefined | non_neg_integer(),
         init_max_uni_streams  :: undefined | non_neg_integer(),
         max_packet_size       :: undefined | non_neg_integer(),
         ack_delay_exp = 3     :: non_neg_integer(),
         migration = true      :: boolean(),
         reset_token           :: undefined | binary(),
         preferred_address     :: undefined | #quic_pref_addr{}
        }).

-record(quic_data, 
        {
         type             :: client | server,
         vx_module        :: atom(),
         version          :: undefined | #quic_version{},
         conn             :: undefined | #quic_conn{},
         pkt_nums = #{initial => {0, 0, 0},
                      handshake => {0, 0, 0},
                      protected => {0, 0, 0}} :: map(),
         %% The tuple is for packet numbers to send, to receive, and largest acked.
         timer_info       :: undefined | map(),
         cc_info          :: undefined | map(),
         send_queue       :: undefined | quic_staging:staging(),
         priority_num     :: undefined | non_neg_integer(),
         params           :: undefined | #quic_params{},
         current_data     :: undefined | non_neg_integer(),
         %% Keeps track of how much data has been sent.
         crypto = #quic_crypto{} :: #quic_crypto{},
         retry_token      :: undefined | binary()
        }).

-record(tls_record,
        {
         type :: undefined | atom(),
         quic_version :: undefined | version(),
         other_quic_versions :: undefined | [version()],
         offset :: undefined | non_neg_integer(),
         length :: undefined | non_neg_integer(),
         legacy_version :: undefined | tls_version(),
         tls_supported_versions = [] :: [tls_version()],
         cipher_suites = [] :: [{atom(), atom()}],
         groups = [] :: [any()],
         supported_groups = [] :: [group()],
         peer_cert = <<>> :: binary(),
         root_cert = <<>> :: binary(),
         cert_chain = [] :: [binary()],
         key_share = [] :: [{group(), binary()}],
         signature :: undefined | binary(),
         signature_algs = [] :: [{atom(), atom(), atom()}],
         cert_verify :: undefined | binary(),
         server_cert_type :: undefined | atom(),
         quic_params :: undefined | #quic_params{},
         temp_bin :: undefined | binary() 
                %% This holds the binary of the tls record to add to the transcript
                %% after it is validated.
        }).

